** Intro

Проект возможно более быстрой wasm-машины. Он же - план работ.

Есть несколько подходов для оптимизации скорости ВМ, которые можно применить. Ускорение, заложенное в предыдущих шагах, поддерживет следующие шаги.

** Baseline

Switched-интерпретатор со стадиями выборки, декодирования, перехода.

** Tail-recursuve интерпретатор

Вместо диспетчера построенного на switch или таблице переходов мы размещаем стадии выборки и декодирования в конце каждой инструкции. Ускорение достигается тем, что диспетчеризация имеет историю переходов, связанную с выполняемой командой и предсказатель ветвлений работает эффективнее. Ускорение в 2 раза отностительно Switched

** Размещение структур виртуальной машины в регистрах

Вместо обращений в память для всех переменных состояния ВМ мы резервируем соответсвующие регистры. Ускорение достигается использованием более быстрого регистрового доступа и снижением давления на кэш данных. Предполагаемое ускорение - в 1.5-2 раза относительно предыдущего варианта Tail-recursuve (рассчитано из разницы скорости доступа между регистрами и L1-кэшем данных, отдельно не измерялось)

** Написание сервисных процедур на ассемблере

Оптмимизированные с точки зрения ветвлений сервисные процедуры будут короче и быстрее чем созданные компилятором. Кроме того префиксы переходов позволяют дать дополнительную информацию процессору о вероятности условных переходов (техника пока не применялась). Ожидаемое ускорение 10-20% относительно предыдущего варианта

** Кэширование верхних элементов стека в регистрах

Так как стековые виртуальные машины работают в основном с верхушкой стека, то все незадействованные регистры можно применить для того чтобы кэшировать верхние элементы стека в них. Ускорение - в 2 раза относительно ассемблерного интерпретатора (отдельно не измерялось, но хвосторекурсивный ассемблерный регистровый интерпретатор с кэшированием двух верхних элементов стека дает 3 секунды против 32х, т.е. 10-кратное ускорение. *Будем считать его новым Baseline*

** Отказ от таблицы сервисных процедур

Мы можем использовать настраиваемый релокейт для всех диспетчеров чтобы упростить команду, которая осуществляет переход к следующей процедуре. Это позволяет избавиться о коссвенной адресации и освободить один регистр, но все процедуры должны иметь одинаковую длину. В случае если процедура длиннее, она может иметь безусловный переход на свой "хвост", который хорошо предсказывается и не приводит к деградации производителльности, если попадает в кэш. Дает 1%-5% ускорения.

** Выбор набора сервисных процедур в зависимости от текущего состояния стека

При работе некоторых сервисных процедур они вынуждены по окончании своей работы приводить стек в консистентное состояние, чтобы следующие процедуры могли начать свою работу. Мы можем убрать эти накладные расходы сделав варианты процедур, которые работают с неконсистентным состоянием. Тогда завершающая сервисная процедура делает прыжок на вариант следующей выполняемой процедуры, который готов работать с неконсистентным состоянием. Предполагаемое ускорение - от 10-20%, возможно больше (не проверялось). Оптимизация сильно зависит от размера кэша инструкций (количество процедур увеличиается кратно) - требуется следить чтобы давление на кэш не возрастало, иначе производительность может даже ухудшится.

** Формирование суперинструкций

Ускорение обеспечивается за счет устранения диспетчеризации в конце каждой команды, входящей в базовый блок трансляции. Требуется предварительный анализ кода для определения границ блоков (он несложен и быстр). Суперинструкции могут формироваться отложенно, после получения статистики от счетчиков производительности, чтобы избежать обработки кода который исполняется редко. Дает ускорение на 30% относительно нового *Baseline* при средней длине суперинструкции в 4 инструкции. Для WASM-машины длина (и ускорение) скорее всего будет больше.

** Оптимизация суперинструкций

Применение локальных оптимизаций над базовыми блоков - позволяет выкинуть лишние операции работы со стеком внутри суперинструкций. Ожидаемое ускорение 20% относительно предыдущего пункта.

** Проверка диапазонов с помощью cmov

Каждое обращение к памяти проверяется на выход за разрешённые диапазоны. Эта проверка выполняется достаточно быстро: адрес сравнивается с максимально допустимым, после чего делается cmov. Если адрес не лежал в пространстве адресов ВМ, мы обратимся к guard‑страничке и попадём в обработчик SIGSEGV. После этого мы остановим работу нашей виртуальной машины.

Для стека вызовов используется обычный x86-стек. Стек с данными находится в защищённой области памяти. Таким образом, перетереть адрес возврата из функции не получится.

В WebAssembly нет инструкции jump. JIT‑скомпилированный код не может «прыгать» по произвольным адресам (и по невыровненным тоже).

** JIT-компиляция

Ускорение за счет полного отказа от диспетчеризации и провязывания всех блоков прямыми переходами, распределения регистров и внутрипроцедурных оптимизаций. Ускорение не измерялось, будет зависеть от набора оптимизаций и скорости работы JIT-компилятора. Можно предположить что может дать 2-кратное ускорение относительно предыдущего пункта.
